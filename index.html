<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Document</title>
    <link rel="stylesheet" href="./css/style.css" />
  </head>
  <body>
    <canvas class="canvas brick"></canvas>
    <canvas class="canvas bg"></canvas>
    <script type="module" src="./src/main.ts"></script>
    <script nomodule="">
      const cvs = document.querySelector(".cvs.brick")
      const posCvs = document.querySelector(".cvs.pos")
      const next = document.querySelector(".next")
      const ctx = cvs.getContext("2d")
      const posCtx = posCvs.getContext("2d")
      const nextCtx = next.getContext("2d")

      next.height = 80
      next.width = 80

      const pos = Array.from({ length: config.heightNum }, (_) => 0)
      const colorPos = Array.from(
        { length: config.heightNum },
        () => new Array(config.widthNum)
      )



      const getRandomLetter = (bricks) => {
        const letters = Object.keys(bricks)
        return letters[(Math.random() * letters.length) >> 0]
      }

      const getStructBinary = (structure, x) => {
        const binary = []
        const len = structure[0].length
        for (let i = structure.length - 1; i >= 0; i--) {
          let r
          let carry = config.widthNum - x - len
          if (carry >= 0) {
            r = parseInt(structure[i], 2) << carry
          } else {
            r = parseInt(structure[i], 2) >> -carry
          }
          binary.unshift(r)
        }
        return binary
      }

      //11000   00111

      const eliminate = (pos, colorPos, config) => {
        let r = Math.pow(2, config.widthNum) - 1
        for (let i = pos.length - 1; i >= 0; i--) {
          if (pos[i] === r) {
            pos.splice(i, 1)
            pos.unshift(0)
            colorPos.splice(i, 1)
            colorPos.unshift(new Array(config.widthNum))
            updateScore(config.score++)
            updatePos()
          }
        }
      }

      const updatePos = () => {
        posCtx.clearRect(0, 0, posCvs.width, posCvs.height)
        drawPos(posCtx, pos, colorPos, config)
      }

      const updateScore = (score) => {
        ctx.fillStyle = "red" // 设置文字颜色
        ctx.font = `${devicePixelRatio * 20}px Arial` // 设置文字样式
        ctx.lineWidth = 2
        ctx.fillText(
          `score:${score}`,
          cvs.width - 100 * devicePixelRatio,
          50 * devicePixelRatio
        )
      }

      /**
       * 比同层 没有同层 直接返回false
       * 111
       * 010
       * 000
       * 这种情况 y+i会下标越界
       */
      const canDown = (binary) => {
        for (let i = binary.length - 1; i >= 0; i--) {
          if ((pos[brick.y + i] ?? 2 ** config.widthNum - 1) & binary[i]) {
            return false
          }
        }
        return true
      }

      const record = (binary) => {
        for (let i = binary.length - 1; i >= 0; i--) {
          if (binary[i] === 0) continue
          pos[brick.y + i - 1] |= binary[i]
          for (
            let j = config.widthNum - 1, r = binary[i];
            r !== 0;
            j--, r >>= 1
          ) {
            if (r & 1) {
              colorPos[brick.y + i - 1][j] = brick.color
            }
          }
        }
        updatePos()
        brick = nextBrick
        nextBrick = new CreateBrick(config)
        // if(!canDown(brick.binary)){
        // 	console.log('结束');
        // }
      }

      const drawPos = function (ctx, map, colors, { brickWidth, brickHeight }) {
        for (let i = 0; i < map.length; i++) {
          for (let j = config.widthNum - 1, r = map[i]; r !== 0; j--, r >>= 1) {
            if (r & 1) {
              drawBrick(
                ctx,
                j * brickWidth,
                i * brickHeight,
                brickWidth,
                brickHeight,
                colors[i][j]
              )
            }
          }
        }
      }
      let brick = new CreateBrick(config)
      let nextBrick = new CreateBrick(config)

      const brickUpdate = (function () {
        const fn = throttle(function () {
          brick.update()
          if (!canDown(brick.binary)) {
            record(brick.binary)
          }
        }, 1000 / config.speed)
        return function brickUpdate() {
          brick.draw(ctx)
          fn()
        }
      })()

      const [render, cancelRaf] = customRaf(function (ctx, config) {
        ctx.clearRect(0, 0, cvs.width, cvs.height)
        eliminate(pos, colorPos, config)
        brickUpdate()
        updateScore(config.score)
        userAction()
        nextCtx.clearRect(0, 0, cvs.width, cvs.height)
        drawLetter(nextCtx, { ...nextBrick, x: 0, y: 0 })
      }, config.FPS)

      const isKeyPressed = (function () {
        const isKeyPressed = {}
        Object.keys(config.control).forEach((key) => {
          isKeyPressed[key] = false
        })
        return isKeyPressed
      })()

      let lastTime = 0
      const userAction = function () {
        if (activeKey === null) return
        let now = Date.now()
        const ctrlKey = findCtrlKey(activeKey)
        if (!isKeyPressed[ctrlKey]) {
          lastTime = now
          let handle = getHandle(ctrlKey)
          handle && handle()
          isKeyPressed[ctrlKey] = true
          return
        }
        let interval = getBrickDownInterval(ctrlKey)
        if (now - lastTime >= interval) {
          lastTime = now - ((now - lastTime) % interval)
          let handle = getHandle(ctrlKey)
          handle && handle()
        }
      }

      const findCtrlKey = (activeKey) => {
        for (const [key, value] of Object.entries(config.control)) {
          if (value.some((item) => item === activeKey)) {
            return key
          }
        }
      }

      const getBrickDownInterval = (ctrlKey) => {
        let interval = 1000 / config.keySpeed
        if (config.speedUpKey.includes(ctrlKey))
          interval = 500 / config.keySpeed
        return interval
      }

      const getHandle = (function () {
        const direction = {
          left: "left",
          right: "right",
          down: "downOne",
          bottom: "downBottom",
          up: "rotate",
        }
        return (ctrlKey) => {
          if (config.onceKey.includes(ctrlKey) && isKeyPressed[ctrlKey]) {
            return null
          }
          return brick[direction[ctrlKey]].bind(brick)
        }
      })()

      let activeKey = null
      window.onkeydown = (e) => {
        switch (e.key) {
          case config.pause:
            running ? cancelRaf() : render(ctx, config)
            running = !running
            break
          default:
            Object.values(config.control).forEach((item) => {
              if (item.includes(e.key)) activeKey = e.key
            })
        }
      }

      let running = true
      window.onkeyup = (e) => {
        switch (e.key) {
          case activeKey:
            activeKey = null
          default:
            let ctrlKey
            if ((ctrlKey = findCtrlKey(e.key))) {
              isKeyPressed[ctrlKey] = false
            }
        }
      }

      render(ctx, config)
    </script>
  </body>
</html>
